import numpy as npfrom numpy import linalg as LAfrom scipy.misc import factorialimport model as mdimport datasetReader as dfimport utilsimport pickleimport timefrom tqdm import tqdm# np.warnings.filterwarnings('ignore')num_traces = 4dataset = df.Dataset('/Users/adel/Documents/workspace/datasetSimulator/logs/goodDs', num_traces)model = md.Model(6, dataset, "constrained")print(model.uniformisation_rate)print(dataset.uniformisatoin_rate())# print(model.M)N = model.NR = model.Rstored_fw_values = np.zeros((num_traces , 1, N))stored_bw_values = np.ones((num_traces , N, 1))stored_p_values = np.zeros((num_traces , N, N))def getSubV(i, l):    return stored_fw_values[i, :, :] * LA.matrix_power(model.P0, l)def getSubW(i, l):    return LA.matrix_power( model.P0, l) * model.P1 * stored_bw_values[i, :, :]def getV(i, r):    V = np.zeros(( model.N, r ))    for j in range( r ):        V[:, j] = getSubV(i, j)    return Vdef getW(i, r):    W = np.zeros(( r, model.N ))    for j in range( r ):        W[j, :] = np.transpose( getSubW(i, k-1-j) )    return W########################################################################################################################if __name__ == '__main__':    epsilon = 1    round_counter = 0    while epsilon > 0.2 and round_counter < 18:        # init X0 to a matrix and X1 to a vector, according to the fact that we work on MMPP, i.e. D1 diagonal form        X0_tmp = np.zeros((N, N))        X1_tmp = np.zeros((N, 1))        Z = np.zeros((N, R))        for trace in tqdm(model.traces):            M = len(trace)            stored_fw_values = np.zeros((M, 1, N))            stored_bw_values = np.ones((M, N, 1))            X0 = np.zeros( (M, N, N) )            X1 = np.zeros( (M, N, N) )            D = model.uniformisation_rate ** M * model.forward_likelihood_absolute(M - 1, trace).sum()            # Store values fot A and B for a faster computation            for i in range(M):                stored_fw_values[i, :, :] = model.forward_likelihood(i, trace)                stored_bw_values[i, :, :] = model.backward_likelihood(i + 1, trace)            for i in range(M):                (l, r) = utils.getPoissonBounds(model.uniformisation_rate * trace[i][0], .1)                # fw is a 1xN vector                fw = stored_fw_values[i, :, :]                # bw is an Nx1 vector                bw = stored_bw_values[i, :, :]                # Retrive some informations from the model                q = model.uniformisation_rate                t = trace[i][0]                # Z row for the observed event should be updated by adding a                Z[:, trace[i][1]] = Z[:, trace[i][1]] + fw                for k in range(l, r):                    e = np.exp(-q * t) * np.power(q * t, k) / factorial(k)                    if e < np.inf:                        V = getV(i, k)                        W = getW(i, k)                        X0_tmp = X0_tmp + e * V.dot( W )                        X1_tmp = X1_tmp + e * np.multiply(getSubV(i, k), np.transpose(bw))            X0[i, :, :] = 1 * np.multiply(X0_tmp, model.P0 )            X1[i, :, :] = 1 * np.multiply(X1_tmp, model.P1 )            # Z = D * Z        Y0 = X0.sum(axis=0)        Y1 = X1.sum(axis=0)        normFactor = Y0.sum(axis=1) + Y1.sum(axis=1)        Y0 = Y0 / normFactor[:, np.newaxis]        Y1 = Y1 / normFactor[:, np.newaxis]        Z = Z / Z.sum(axis=1)[:, np.newaxis]        round_counter = round_counter+1        epsilon = max(            LA.norm( model.P0 - Y0, 2),            LA.norm( model.P1 - Y1, 2),           )        model.P0 = np.matrix( Y0 )        model.P1 = np.matrix( Y1 )        model.M = np.matrix( Z )    # EXIT FROM PROCEDURE    # print("Final P0")    # print( model.P0 )    # print("Final P1")    # print( model.P1 )    print("Final M")    print( model.M )    model.compute_generators()    model_name = str("model"+str(N)+"states-"+time.strftime("%Y%m%d%H%M"))+".p"    pickle.dump(model, open("saved_models/"+                            model_name, "wb"))    print(model_name)    # D1 = model.P1 * model.uniformization_rate    #    # D0 = model.P0 * model.uniformization_rate - model.uniformization_rate * np.eye(N,N)#*\    #    # print("\nD0:")    # print( D0 )    # print("\nD1:")    # print( D1 )